
## Зачем изучать алгоритмы?
- Алгоритмы - это про способ мыслить о программах
- Вы сможете писать оптимизированный и масштабируемый код - получив знания о различных структурах данных и алгоритмах, вы можете определить, какую выбрать структуру данных и алгоритм в различных условиях.
- Эффективное использование времени и памяти. Знание структур данных и алгоритмов поможет вам писать код, который работает быстрее и требует меньшего объема памяти.
 
## Учите алгоритмы по книгам
- Введение в алгоритмы, Томас Х. Кормен - это одна из лучших книг по алгоритмам, в которой подробно рассматривается широкий спектр алгоритмов.
- Алгоритмы Роберта Седжвика - это ведущий учебник по алгоритмам, широко используемый в колледжах и университетах.
- Искусство программирования, Дональд Э. Кнут - эта книга считается лучшей, если вы знакомы с предметом и ищете более глубокое понимание.

## Алгоритмические метод решения задач:

- **Brute-Force** - перебирайте все варианты в лоб.

- **Divide and Conquer** - разбивайте задачу на подзадачи и комбинируйте их (используют в алгоримах сортировки слиянием и банарном поиске).

- **Dynamic Programming** - Кешируйте промежуточные результаты для их повторного использования. 

Подход `Сверху Вниз` - кеширования результатов повторяющихся расчетов в таблицу и их использования по мере хода алгоритма, подход `Снизу Вверх` - кеширование всех результатов подзадач в таблицу и после в нужной последовательности сбор результатов) Пример, задача о максимальной вместимости рюкзака, для перебора всех возможных вариантов O(2^N), быстрее решать подзадачи O(N^2).

[Dynamic Programming](https://www.topcoder.com/thrive/articles/Dynamic%20Programming:%20From%20Novice%20to%20Advanced) - Кешируйте промежуточные результаты для их повторного использования. 

[Dynamic Programming](https://brestprog.by/topics/dp/)

[Dynamic Programming](https://brestprog.by/topics/bitmasks/)

- **Greedy Algorithm** - пытайтесь взять что-то выгодное в первую очередь (жадный алгоритм).

- **Blacktracking** - оптимизация Brute-Force отменяя отдельные затратные операции еще до начала их выполнения.Т.е. отбросить заведомо неверный путь, недопустив затрат на его расчет еще до начала самого расчета.

- **Local Search** - пытайтесь выбрать решение которое не хуже предыдущего (градиентный спуск/подьем).

- **Transform and Conquer** - преобразование данных для лучшего их использования или преобразование самой задачи (индекс в базах данных, разместить данные особым способом для быстрого поиска. Инвертированные индекс и Column-oriented DB MS).
 
- [Поиск](https://www.topcoder.com/thrive/tracks?tax=Search&track=Competitive%20Programming) в ширину (BFS)

### Фильтр Блума и HyperLogLog

Вероятностные структыры данных. Они дают ответ,который может оказаться ложным, но с большой вероятностью является правильным. 
Фильтры Блума очень удобны тогда, когда не нужно хранить точный ответ. Пример, что бы уменьшить количество проверок наличия ключа в базе можно получить вероятный ответ наличия или точно отрицательный используя Фильтр Блума

### Линейное программирование

Линейное программирование используется для максимизации некоторой характеристики при заданных ограничениях. 
Предположим, ваша компания выпускает два продукта: рубашки и сумки. На рубашку требуется 1 м 5 пуговиц. 
На изготовление сумки необходимо 2 м ткани и 2 пуговицы. У вас есть 11 м ткани и 20 пуговиц. 
Рубашка приносит прибыль $2, а сумка - $3. Сколько рубашек и сумок следует изготовить для получения ткани и максимальной прибыли?

## Асимптотическая сложность алгоритмов

Сложность алгоритма - это то, как будет расти потребление ресурсов с увеличением N количества елементов до бесконечности. Наивная реализация алгоритма/задачи которая превышает заданный лимит времени выполнения требует другого решения с учетом оптимизации количества операций и выделенных ресурсов. Если ваше решение не укладывается в ограничение по памяти, оно скорее всего не уложится и в ограничение по времени.

Количество операций для n = 10_000 елементов:

-  `O(1)`, константная - 1 операция
-  `O(log n)`, логарифмическая (как в бинарном поиске) - ~13 операций
-  `O(n)`, линейная - 10_000 операций
-  `O(n^2)`, квадратичная - 100_000_000 операций
-  `O(n^3)`, кубическая (как в тройном влоденном цикле) - 1_000_000_000_000 операций
-  `O(n!)`, факториал 10 000 000 000 000 000 000 000 000 ... операций

![Comparison of algorithms.](https://github.com/Jekahome/Algorithms/blob/_img_/algo.jpg "Comparison of algorithms.")

 
## Асимптотическая сложность ф-ций в нотации Big-O:

1. константная `O(1)` 
2. логарифмическая `O(log N)`, `O(log^2 N)`
3. корень из N `O(sqrt N)`
4. линейная `O(N)` 
5. линейная `O(N+M)` 
6. линеарифмическая/linearithmic `O(N*log N)`, `O(N*log^2 N)` или `O(N*M)`,`O(N*sqrt M)`
7. полиномиальная квадратичная `O(N^2)`,`O(N^2*log N)`  или кубическая `O(N^3)` 
8. экспоненциальная `O(2^N)`
9. факториал `O(n!)`
 
```rust
/* 
Временная сложность алгоритма - константная O(1)
Это лучшее. Алгоритм всегда занимает одинаковое количество времени, независимо от объема данных. 
Пример: поиск элемента массива по его индексу.
*/
fn algo_1(v: &[i32], index: usize) -> Option<i32>{
    if index < v.len(){
        return Some(v[index]);
    }
    None    
} 
// или
let x = &[1, 2, 4];
unsafe {
    assert_eq!(x.get_unchecked(1), &2);
}

// или
vec.push(), vec.pop()

``` 

```rust
/* 
Временная сложность алгоритма - логарифмическая O(log N)
(`log N` это `log _2 N` в какой степени должна быть двойка чтобы получилось N, это и будет количество операций)
каждая итерация сокращает вдвое количество элементов/значение
Перевод числа в двоичное представление
TODO:Логарифм по основанию `a` от аргумента `x` — это степень, в которую надо возвести число `a`, чтобы получить число `x`

log_2 64 = 6 так как 2^6=64

Довольно здорово. Подобные алгоритмы уменьшают вдвое объем данных на каждой итерации. Если у вас 100 предметов, то чтобы найти ответ, потребуется около 7 шагов. При наличии 1000 элементов требуется 10 шагов. А для 1 000 000 предметов требуется всего 20 шагов. Это очень быстро даже для больших объемов данных. Пример: бинарный поиск.
*/
fn algo_2(mut decimal:u8) -> Option<String>{
    if decimal == 0 {return None;}
    let mut binary = String::from(""); 
    while decimal > 0 {
        binary = format!("{}{}",decimal%2,binary);
        decimal = decimal.div_floor(2);
    }
    Some(binary)
}

// или
let j = 1
while j < n {
  // do constant time stuff
  j *= 2
}

```

```rust
// Временная сложность алгоритма - корень из N (sqrt N)
// условие выхода из цикла x^2 следовательно цикл прекратится когда x >= sqrt N
// TODO: Корень `n-й` степени из числа `a` определяется как такое число `b`, что `b^n=a` 
//       Здесь `n` — натуральное число, называемое показателем корня (или степенью корня); 
//       как правило, оно больше или равно 2, потому что случай `n=1` не представляет интереса.
//       Пример: Корнями 2-й степени из числа 9 являются +/-3  т.е. `9 sqrt^2=3`  так как 3^2=9,а `64 sqrt^3=4` так как 4^3=64
//       И график O(sqrt N) будет расти быстрее, следовательно медленнее работать чем график O(log N)
//       так как для N=64 => `log_2 64 = 2^6 = 64 => 6` < `64 sqrt^2 = 8^2 = 64 => 8`
//       т.е. для log мы двойку возводим нужную степень,а для sqrt нужно само число для возведения в квадрат 
fn algo_sqrt(v:&Vec<i32>){
    let mut x = 0;
    while x*x < v.len() {
        x+=1;
    }
}
```

```rust
/* 
Временная сложность алгоритма - линейная O(N)

Хорошая производительность. Если у вас 100 элементов, это выполняет 100 единиц работы. При удвоении количества элементов алгоритм будет выполняться ровно в два раза дольше (200 единиц работы). Пример: последовательный поиск.
*/
fn algo_3(v:&Vec<i32>,n:i32) -> bool{
    for i in v{
        if i == &n{
            return true;
        }
    }
    false
}
```

```rust
// Временная сложность алгоритма - линейная O(N + M) 
fn algo_5(n:&Vec<i32>,m:&Vec<i32>,element:&i32) -> Option<i32>{
    let mut value:i32 = 0;
    for i_n in n{
       if i_n > element{
         value = *i_n;
       }
    }
    if value == 0{return None};
    for i_m in m {
        if &value == i_m{
            return Some(*i_m);
        }
    }
    None
}
```

```rust
/*
Временная сложность алгоритма - линеарифмическая O(N * M) 

Достойная производительность. Это немного хуже линейного, но не так уж плохо. 
Пример: самые быстрые алгоритмы сортировки общего назначения.
*/
fn algo_6(n:&Vec<i32>,m:&Vec<i32>) -> Option<i32>{
    for i_n in n{
        for i_m in m{
            if i_n == i_m{
                return Some(*i_m);
            }
        }
    }
    None
}
```

```rust
/* 
Временная сложность алгоритма - полиномиальная (квадратичная) сложность O(N^2)
 1 + 2 + 3 + 4 + ... + N => O(N^2)
 N-1 * N-1 = N^2

Как-то медленно. Если у вас 100 элементов, это 100^2 = 10 000 единиц работы. 
Удвоение количества предметов делает процесс медленнее в четыре раза (поскольку 2 в квадрате равно 4). 
Пример: алгоритмы, использующие вложенные циклы, такие как сортировка вставками.
*/
fn algo_6_bubble_sort(v:&mut Vec<i32>){
    for i in 0..v.len()-1 {
        for j in 0..v.len()-1 {
            if v[j] > v[j+1]{
                let swap = v[j];
                v[j]=v[j+1];
                v[j+1]=swap;
            }
        }
    }
}

// или
for i in 0..n {
  for j in 0..n {
    ...
  }
}
```

```rust
/* 
Временная сложность алгоритма - полиномиальная (кубическая) сложность O(N^3)

Низкая производительность. Если у вас 100 элементов, это 100^3 = 1 000 000 единиц работы.
Удвоение входного размера делает его в восемь раз медленнее. Пример: умножение матрицы.
*/
for i in 0..n {
  for j in 0..n {
    for k in 0..n {
       ...
    }
  }
}

``` 


```rust
/* 
Временная сложность алгоритма - экспоненциальная O(2^N)
 2^0 + 2^1 + 2^3 + ... + 2^N => O(2^N)

Очень плохая производительность. Вы хотите избежать подобных алгоритмов, но иногда у вас нет выбора. 
Добавление всего лишь одного бита к входным данным удваивает время работы. Пример: задача коммивояжера.

 cargo +nightly run
*/
fn main() {
    aasert_eq!(Some("11111110"),algo_2(254));

    let mut v = vec![5,7,1,4];
    algo_7_bubble_sort(&mut v);
    assert_eq!(vec![1,4,5,7],v);
}
```

```rust
/* 
Временная сложность алгоритма - факториал O(n!)
Невыносимо медленно. Буквально на то, чтобы что-то сделать, уходит миллион лет.
В задаче "Комиивояжора" - построение всех возможных маршрутов, используется в картах или просто рекурсия
*/
fn factorial(n: i32) {
    for i in 0..n {
       factorial(n - 1)
    }
}

```


### Links

[8 лучших алгоритмов, которые должен знать каждый программист](https://vc.ru/u/1389654-machine-learning/593476-8-luchshih-algoritmov-kotorye-dolzhen-znat-kazhdyy-programmist)

[AllAlgorithms](https://github.com/AllAlgorithms/rust) 

[geeksforgeeks.org](https://www.geeksforgeeks.org/fundamentals-of-algorithms/?ref=shm)

[Algorithmic complexity / Big-O / Asymptotic analysis](https://github.com/jwasham/coding-interview-university#algorithmic-complexity--big-o--asymptotic-analysis)

[Комбинаторика](https://brestprog.by/topics/combinatorics/)

[TheAlgorithms Rust](https://github.com/TheAlgorithms/Rust/tree/master)

[Visual algo](https://visualgo.net/en)

[Visual Algorithms](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

[Algorithms e-maxx.ru](http://e-maxx.ru/algo/)

[Sorting-Algorithms on Rust](https://github.com/diptangsu/Sorting-Algorithms/tree/master/Rust)

[Sorting algorithm Wiki](https://en.wikipedia.org/wiki/Sorting_algorithm)

[Грокаем алгоритмы GitHub](https://github.com/egonSchiele/grokking_algorithms)

[Radix sort](https://www.youtube.com/watch?v=_KhZ7F-jOlI)
