/// 
/// Временная сложность:
/// временная сложность алгоритма «разделяй и властвуй» для поиска максимального и минимального элемента в массиве равна O (n). 
/// Это связано с тем, что каждый раз, когда мы делим массив пополам, общее количество делений будет log(n). 
/// В каждом делении мы сравниваем два элемента, чтобы найти максимальный и минимальный элемент, что занимает постоянное время. 
/// Следовательно, общая временная сложность равна O(n*log(n)).
/// 
/// Пространственная сложность:
/// Пространственная сложность алгоритма «разделяй и властвуй» для поиска максимального и минимального элемента в массиве равна O (log (n)). 
/// Это связано с тем, что мы используем рекурсию для разделения массива на более мелкие части, и каждый рекурсивный вызов занимает место в стеке вызовов. 
/// Максимальная глубина дерева рекурсии равна log(n), то есть столько раз, сколько раз мы можем разделить массив пополам. 
/// Следовательно, пространственная сложность равна O(log(n)).

/// Разделяй и властвуй (D&C) против динамического программирования (DP) 
/// Обе парадигмы (D&C и DP) делят данную проблему на подзадачи и решают подзадачи. Как выбрать один из них для конкретной задачи? 
/// Метод «разделяй и властвуй» следует использовать, когда одни и те же подзадачи не решаются много раз. 
/// В противном случае следует использовать динамическое программирование или мемоизацию. 
/// Например, быстрая сортировка — это алгоритм «разделяй и властвуй», мы никогда больше не оцениваем одни и те же подзадачи. 
/// С другой стороны, для расчета n-го числа Фибоначчи следует предпочесть динамическое программирование
/// 
/// 
/// Преимущества алгоритма «разделяй и властвуй»:
/// 
/// - Сложную проблему можно легко решить.
/// - Он делит всю проблему на подзадачи, поэтому ее можно решать параллельно, обеспечивая многопроцессорность.
/// - Эффективно использует кэш-память, не занимая много места
/// - Уменьшает временную сложность проблемы
/// - Решение сложных проблем: техника «разделяй и властвуй» — это инструмент для концептуального решения сложных проблем. 
///     Например, головоломка Ханойской башни. 
///     Это требует способа разбить проблему на подзадачи и решить их все как отдельные случаи, а затем объединить подзадачи в исходную проблему.
/// - Эффективность алгоритмов. Парадигма «разделяй и властвуй» часто помогает в открытии эффективных алгоритмов. 
///     Это был ключ, например, к алгоритмам быстрой сортировки и сортировки слиянием, а также к быстрым преобразованиям Фурье. 
///     Во всех этих примерах подход D и C привел к улучшению асимптотической стоимости решения. 
///     В частности, если базовые случаи имеют постоянный ограниченный размер, работа по разделению проблемы и объединению частичных решений 
///     пропорциональна размеру проблемы n, и на каждом этапе существует ограниченное число p подзадач размера n/p., 
///     то стоимость алгоритма «разделяй и властвуй» составит O(n log n).
/// - Параллелизм: обычно алгоритмы ЦАП используются в многопроцессорных машинах с системами с общей памятью, где передачу данных между процессорами 
///     не нужно планировать заранее, поскольку отдельные подзадачи могут выполняться на разных процессорах.
/// - Доступ к памяти. Эти алгоритмы естественным образом эффективно используют кэши памяти. Поскольку подзадачи достаточно малы, 
///     чтобы их можно было решить в кеше без использования более медленной основной памяти. Любой алгоритм, который эффективно использует кеш, 
///     называется не обращающим внимания на кеш.
/// - Управление округлением: при вычислениях с округленной арифметикой, например, с числами с плавающей запятой, алгоритм «разделяй и властвуй» 
///     может давать более точные результаты, чем поверхностно эквивалентный итеративный метод. Например, можно добавить N чисел либо с 
///     помощью простого цикла, который добавляет каждое значение к одной переменной, либо с помощью алгоритма D и C, 
///     который разбивает набор данных на две половины, рекурсивно вычисляет сумму каждой половины, а затем добавляет две суммы. 
///     Хотя второй метод выполняет то же количество сложений, что и первый, и оплачивает накладные расходы на рекурсивные вызовы, он обычно более точен.
/// 
/// Недостатками алгоритма «разделяй и властвуй»:
/// 
/// - Может быть сложно определить базовый случай или условие остановки для рекурсивных вызовов.
/// - Возможно, это не самый эффективный алгоритм для решения всех задач.
/// - Ему может потребоваться больше памяти, чем другим алгоритмам, поскольку он предполагает сохранение промежуточных результатов.

/// 
// function to find the maximum no.
// in a given array.
fn dac_max(arr:&[i32], index:usize, l:usize) -> i32 {
    let mut max = 0;
    if l - 1 == 0{
      return arr[index];
    }
    if index >= l - 2{
        if arr[index] > arr[index + 1]{
          return arr[index];
        }else{
          return arr[index + 1];
        }
    }  
    max = dac_max(arr, index + 1, l);    
    if arr[index] > max{
       return arr[index];
    }else{
       return max;
    }   
}
 
// Function to find the minimum no.
// in a given array
fn dac_min(arr:&[i32], index:usize, l:usize) -> i32{
    let mut min = 0;
    if l - 1 == 0{
       return arr[index];
    }
    if index >= l - 2{
        if arr[index] < arr[index + 1]{
          return arr[index];
        }else{
          return arr[index + 1];
       }
    }
     
    min = dac_min(arr, index + 1, l);   
    if arr[index] < min {
       return arr[index];
    }else{
       return min;
    }
}
 
/// $ cargo test divide_and_conquer
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide_and_conquer() {
        let arr = vec![ 70, 250, 50, 80, 140, 12, 14 ];
        let n = arr.len();
        
        let max = dac_max(&arr, 0, n);
        let min = dac_min(&arr, 0, n);
      
        assert_eq!(250, max);
        assert_eq!(12, min);
    }
} 